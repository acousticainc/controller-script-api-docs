"use strict";(self.webpackChunkmixcraft_10_api_docs=self.webpackChunkmixcraft_10_api_docs||[]).push([[3385],{3905:(n,e,t)=>{t.d(e,{Zo:()=>O,kt:()=>f});var a=t(7294);function r(n,e,t){return e in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}function o(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(n);e&&(a=a.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,a)}return t}function T(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?o(Object(t),!0).forEach((function(e){r(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}function i(n,e){if(null==n)return{};var t,a,r=function(n,e){if(null==n)return{};var t,a,r={},o=Object.keys(n);for(a=0;a<o.length;a++)t=o[a],e.indexOf(t)>=0||(r[t]=n[t]);return r}(n,e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(n);for(a=0;a<o.length;a++)t=o[a],e.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(n,t)&&(r[t]=n[t])}return r}var l=a.createContext({}),c=function(n){var e=a.useContext(l),t=e;return n&&(t="function"==typeof n?n(e):T(T({},e),n)),t},O=function(n){var e=c(n.components);return a.createElement(l.Provider,{value:e},n.children)},s="mdxType",u={inlineCode:"code",wrapper:function(n){var e=n.children;return a.createElement(a.Fragment,{},e)}},_=a.forwardRef((function(n,e){var t=n.components,r=n.mdxType,o=n.originalType,l=n.parentName,O=i(n,["components","mdxType","originalType","parentName"]),s=c(t),_=r,f=s["".concat(l,".").concat(_)]||s[_]||u[_]||o;return t?a.createElement(f,T(T({ref:e},O),{},{components:t})):a.createElement(f,T({ref:e},O))}));function f(n,e){var t=arguments,r=e&&e.mdxType;if("string"==typeof n||r){var o=t.length,T=new Array(o);T[0]=_;var i={};for(var l in e)hasOwnProperty.call(e,l)&&(i[l]=e[l]);i.originalType=n,i[s]="string"==typeof n?n:r,T[1]=i;for(var c=2;c<o;c++)T[c]=t[c];return a.createElement.apply(null,T)}return a.createElement.apply(null,t)}_.displayName="MDXCreateElement"},4725:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>l,contentTitle:()=>T,default:()=>u,frontMatter:()=>o,metadata:()=>i,toc:()=>c});var a=t(7462),r=(t(7294),t(3905));const o={},T=void 0,i={unversionedId:"Example Script/example-script",id:"Example Script/example-script",title:"example-script",description:"Here is an example script with comments for reference. If you see functions being used that don't appear in the API, be sure to scroll down after the OnMID() function closes, where many helper functions were created. Some of these are specific to the controller, and some could be reused in other scripts.",source:"@site/docs/Example Script/example-script.md",sourceDirName:"Example Script",slug:"/Example Script/example-script",permalink:"/controller-script-api-docs/docs/Example Script/example-script",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"defaultSidebar",previous:{title:"notificationType",permalink:"/controller-script-api-docs/docs/API Sections/MM"}},l={},c=[],O={toc:c},s="wrapper";function u(n){let{components:e,...t}=n;return(0,r.kt)(s,(0,a.Z)({},O,t,{components:e,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Here is an example script with comments for reference. If you see functions being used that don't appear in the API, be sure to scroll down after the OnMID() function closes, where many helper functions were created. Some of these are specific to the controller, and some could be reused in other scripts."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'\n//This example script is for the Novation Launch Control XL using the Mixcraft 10 Scripting API\n\n// using the Novation Launch Control XL MIDI implementation guide here: https://customer.novationmusic.com/sites/customer/files/novation/downloads/10598/launch-control-xl-programmers-reference-guide_0.pdf\n\n// establish constants for the Launch Control XL\n\n\n// an array of FADER1 - FADER8\nFADERS = [0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52, 0x53, 0x54];\nFADER_OFFSET = 0x4D;\n\n// an array of ROW_1_KNOB_1 - ROW_1_KNOB_8\nROW_1_KNOBS = [0x0D, 0x0E, 0x0F, 0x10, 0x11, 0x12, 0x13, 0x14];\n\n// an array of ROW_2_KNOB_1 - ROW_2_KNOB_8\nROW_2_KNOBS = [0x1D, 0x1E, 0x1F, 0x20, 0x21, 0x22, 0x23, 0x24];\n\n// an array of ROW_3_KNOB_1 - ROW_3_KNOB_8\nROW_3_KNOBS = [0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38];\n\n// an array of ALL KNOBS\nALL_KNOBS = [0x0D, 0x0E, 0x0F, 0x10, 0x11, 0x12, 0x13, 0x14, 0x1D, 0x1E, 0x1F, 0x20, 0x21, 0x22, 0x23, 0x24, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38];\n\n// an array of ROW_1_BUTTON_1 - ROW_1_BUTTON_8\nROW_1_BUTTONS = [0x29, 0x2A, 0x2B, 0x2C, 0x39, 0x3A, 0x3B, 0x3C];\n\n// an array of ROW_2_BUTTON_1 - ROW_2_BUTTON_8\nROW_2_BUTTONS = [0x49, 0x4A, 0x4B, 0x4C, 0x59, 0x5A, 0x5B, 0x5C];\n\n\nSEND_SELECT_BUTTON_UP = 0x68;\nSEND_SELECT_BUTTON_DOWN = 0x69;\n\nTRACK_SELECT_BUTTON_LEFT = 0x6A;\nTRACK_SELECT_BUTTON_RIGHT = 0x6B;\n\nSELECT_OFFSET = 0x0;\n\nDEVICE_BUTTON = 0x69;\nMUTE_BUTTON = 0x6A;\nSOLO_BUTTON = 0x6B;\nREC_ARM_BUTTON = 0x6C;\n\n// 0 == DEFAULT, 1 == PROCESSING\nBUTTON_STATE = 0x0;\nPAGE = 0x1;\nBOTTOM_BUTTON_STATE = 0x0;\nBANK = 0;\n\nLED_OFF = 0x0C;\nLED_GREEN = 0x3C;\nLED_RED = 0x0F;\nLED_YELLOW = 0x3F;\n\nON - 0x7F;\nOFF = 0x0;\n\nMIDI_CHANNEL = 0x8;\n\n\nGlobals.SetDebug(true);\n\nfunction OnStartup() {\n\n    // aelect the first track on launch\n    HandleTrackSelect(0x29);\n\n    // aet the bank size of the grid\n    Track.SetBankSize(8);\n\n    // initialize the bank offset\n    Track.SetBankOffset(0);\n\n    // set a confirmation message\n    Globals.Log("Launch Control XL script started");\n\n    // update the LEDs on the bottom of the controller\n    UpdateBottomButtonState(REC_ARM_BUTTON, ON);\n\n    // set the mode for the bottom buttons, which uses this variable\n    BOTTOM_BUTTON_STATE = 0x2;\n}\n\nfunction OnShutdown() {\n\n    // shutdown confirmation message\n    Globals.Log("Launch Control XL script shutting down");\n\n    // reset LaunchControl XL -- Bnh, 00h, 00h\n    MIDI.SendMIDI(0xB0, MIDI_CHANNEL, OFF, OFF);\n\n}\n\n// update controller with any changes made in Mixcraft\nfunction Notify(notificationType, data1, data2) {\n    if (notificationType == MM.TRACK_MUTE_CHANGE && BOTTOM_BUTTON_STATE == OFF) {\n\n        UpdateBottomButtonLEDs();\n    }\n    if (notificationType == MM.TRACK_SOLO_CHANGE && BOTTOM_BUTTON_STATE == 0x1) {\n\n        UpdateBottomButtonLEDs();\n    }\n    if (notificationType == MM.TRACK_ARM_CHANGE && BOTTOM_BUTTON_STATE == 0x2) {\n\n        UpdateBottomButtonLEDs();\n    }\n\n}\n\n// this receives  all incoming MIDI messages. Here we will filter by type using user-created functions found after the OnMIDI() function and then handle the MIDI data accordingly\nfunction OnMIDI(messageType, midiChannel, value1, value2) {\n\n    // handy variables that we want in scope for all OnMIDI blocks  \n\n    // for knobs that have a 0-1.0 range\n    volume = value2 / 127;\n\n    // for knobs that are centered at 12 o\'clock, like a pan knob\n    centered_knob = ((value2 - 64) / 64);\n\n    // the LaunchControlXL factory Preset 1 is set to MIDI channel 9, so all other MIDI is ignored, just to be safe\n    if (midiChannel == MIDI_CHANNEL) {\n        // ***************************************************************************************\n        // FADERS\n        // ***************************************************************************************\n\n        // if a fader is moved, set the volume of the track by using the FADER array index of the value1 to supply the track parameter\n        if (value1 >= FADERS[0] && value1 <= FADERS[7]) {\n            first_channel = SELECT_OFFSET;\n\n            // fill the track variable by determining the index of the FADER array\n            track = FADERS.indexOf(value1) + SELECT_OFFSET;\n            Track.SetVolume(track, volume);\n        }\n\n        // ***************************************************************************************\n        // KNOBS\n        // ***************************************************************************************\n\n        // if a knob is moved, determine which knob it is and handle accordingly\n        if (IsKnob(value1)) {\n\n            // if the BUTTON_STATE is 0 and PAGE = 0x0, then the DEVICE button is not engaged and the knobs act accordingly: row 1 Send A, row 2 Send B, row 3 Pan\n            // if the BUTTON_STATE is 0 and PAGE = 0x1 and there are more than two Send tracks, then the DEVICE button is not engaged and the knobs act     accordingly: row 1 Send C, row 2 Send D, row 3 Pan\n            // if the BUTTON_STATE is 1 and PAGE = 0x0, then the DEVICE button is engaged and the knobs act accordingly: row 1 EQ High, row 2 EQ Mid, row 3 EQ Low\n            if (BUTTON_STATE == 0) {\n\n                // set the pan of the track by using the ROW_3_KNOBS array index of the value1 to supply the track parameter\n                if (value1 >= ROW_3_KNOBS[0] && value1 <= ROW_3_KNOBS[7]) {\n\n                    // fill the track variable by determining the index of the ROW_3_KNOBS array\n                    knob_index = ROW_3_KNOBS.indexOf(value1);\n                    track = knob_index + GetSelectedTrack();\n                    Track.SetPan(track, centered_knob);\n                }\n\n                // set the value of the Send A of the track by using the ROW_1_KNOBS array index of the value1 to supply the track parameter\n                if (value1 >= ROW_1_KNOBS[0] && value1 <= ROW_1_KNOBS[7]) {\n                    n = (PAGE - 1) * 2;\n\n                    // fill the track variable by determining the index of the ROW_1_KNOBS array\n                    knob_index = ROW_1_KNOBS.indexOf(value1);\n                    track = knob_index + GetSelectedTrack();\n                    Track.SetSendValue(track, n, volume);\n                }\n\n                // set the value of the Send B of the track by using the ROW_2_KNOBS array index of the value1 to supply the track parameter\n                if (value1 >= ROW_2_KNOBS[0] && value1 <= ROW_2_KNOBS[7]) {\n                    n = ((PAGE - 1) * 2) + 1;\n\n                    // fill the track variable by determining the index of the ROW_2_KNOBS array\n                    knob_index = ROW_2_KNOBS.indexOf(value1);\n                    track = knob_index + GetSelectedTrack();\n                    Track.SetSendValue(track, n, volume);\n                }\n            }\n\n            if (BUTTON_STATE == 1) {\n                track = GetSelectedTrack();\n                row = GetKnobRow(value1);\n                volume = value2 / 127;\n                if (PAGE == 1) {\n                    if (row == 0) {\n                        Track.SetEQ(track, Track.EQ_HIGH, volume);\n                    }\n                    else if (row == 1) {\n                        Track.SetEQ(track, Track.EQ_MID, volume);\n                    }\n                    else if (row == 2) {\n                        Track.SetEQ(track, Track.EQ_LOW, volume);\n                    }\n                }\n                if (PAGE == 2) {\n                    if (row == 0) {\n                        Track.SetCompressor(track, volume);\n                    }\n                    else if (row == 1) {\n                        Track.SetDrive(track, volume);\n                    }\n                    else if (row == 2) {\n                    }\n                }\n            }\n        }\n\n        // ***************************************************************************************\n        // BUTTONS\n        // ***************************************************************************************\n\n        // if the DEVICE_BUTTON, MUTE_BUTTON, SOLO_BUTTON, or REC_ARM_BUTTON is pressed, handle appropriately\n        if (messageType == 0x90 && value2 == ON) {\n\n            // update the DEVICE_BUTTON state and LED\n            if (value1 == DEVICE_BUTTON) {\n                HandleDeviceButton();\n            }\n\n            // update the Track Focus button\n            if (value1 >= ROW_1_BUTTONS[0] && value1 <= ROW_1_BUTTONS[7]) {\n                HandleTrackSelect(value1);\n            }\n\n            if (value1 == MUTE_BUTTON | value1 == SOLO_BUTTON | value1 == REC_ARM_BUTTON) {\n                UpdateBottomButtonState(value1, value2);\n\n                // If BOTTOM_BUTTON_STATE == 0, then ROW_2_BUTTONS are MUTE, when BOTTOM_BUTTON_STATE == 1, then ROW_2_BUTTONS are SOLO, when BOTTOM_BUTTON_STATE == 2, then ROW_2_BUTTONS are REC_ARM. Update the LEDs accordingly\n                if (BOTTOM_BUTTON_STATE == 0) {\n                    UpdateBottomButtonLEDs();\n                }\n                else if (BOTTOM_BUTTON_STATE == 1) {\n                    UpdateBottomButtonLEDs();\n                }\n                else if (BOTTOM_BUTTON_STATE == 2) {\n                    UpdateBottomButtonLEDs();\n                }\n            }\n\n            // if the BOTTOM_BUTTON_STATE == 0, then ROW_2_BUTTONS are MUTE, when BOTTOM_BUTTON_STATE == 1, then ROW_2_BUTTONS are SOLO, when BOTTOM_BUTTON_STATE == 2, then ROW_2_BUTTONS are REC_ARM. Handle the button press accordingly\n            if (BOTTOM_BUTTON_STATE == 0) {\n                if (value1 >= ROW_2_BUTTONS[0] && value1 <= ROW_2_BUTTONS[7]) {\n                    HandleMuteButton(value1, value2);\n                }\n            }\n            else if (BOTTOM_BUTTON_STATE == 1) {\n                if (value1 >= ROW_2_BUTTONS[0] && value1 <= ROW_2_BUTTONS[7]) {\n                    HandleSoloButton(value1, value2);\n                }\n            }\n            else if (BOTTOM_BUTTON_STATE == 2) {\n                if (value1 >= ROW_2_BUTTONS[0] && value1 <= ROW_2_BUTTONS[7]) {\n                    HandleRecArmButton(value1, value2);\n                }\n            }\n            UpdateBottomButtonLEDs();\n        }\n\n        // Handle the SEND_SELECT_BUTTONS\n        if (value1 == SEND_SELECT_BUTTON_DOWN || value1 == SEND_SELECT_BUTTON_UP && value2 == ON && messageType == MIDI.CC_MESSAGE) {\n            HandleSendSelect(value1, value2);\n        }\n\n        // if the TRACK_SELECT_BUTTON_LEFT is pressed, make sure there is a bank of 8 tracks available to move to, if so, set the tack to 8 tracks to the left, if not, move one track at a time until the first track is selected\n        if (value1 == TRACK_SELECT_BUTTON_LEFT || value1 == TRACK_SELECT_BUTTON_RIGHT && value2 == ON && messageType == MIDI.CC_MESSAGE) {\n            HandleTrackSelection(value1, value2, messageType);\n            HandleTrackSelect(ROW_1_BUTTONS[0]);\n            UpdateBottomButtonLEDs();\n        }\n    }\n\n\n    /// END OF LINE LOGGING\n    UpdateBottomButtonLEDs();\n}\n\n// END OF OnMIDI() section\n// ***************************************************************************************\n// ***************************************************************************************\n// ***************************************************************************************\n\n\n// ***************************************************************************************\n// USER HELPER FUNCTIONS\n// ***************************************************************************************\n\n// a function that returns the \nfunction GetSelectedTrack() {\n    track = 0;\n    numTracks = Track.NumTracks();\n    for (i = 0; i < numTracks; i++) {\n        if (Track.IsSelected(i)) {\n            track = i;\n        }\n    }\n    return track;\n}\n\n// a function that gets the index of the the selected track relative to the bank of 8 tracks\nfunction GetSelectedTrackIndex() {\n    track = GetSelectedTrack();\n    return track % 8;\n}\n\n\n// a function that returns a bool value based on if the control is a knob.  This is used to determine if the control is a knob or a button\nfunction IsKnob(control) {\n    if (control >= ROW_1_KNOBS[0] && control <= ROW_3_KNOBS[7] && messageType == MIDI.CC_MESSAGE) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\n// determines if the MIDI message is from a button\nfunction IsButton(value1) {\n    if (value1 >= ROW_1_BUTTONS[0] && value1 <= ROW_3_BUTTONS[7] && messageType == MIDI.NOTE_ON_MESSAGE) {\n        return true;\n    } else {\n        return false;\n    }\n\n}\n\n// a function tha determines if value1 is of a fader\nfunction IsFader(value1) {\n    if (value1 >= FADERS[0] && value1 <= FADERS[7] && messageType == MIDI.CC_MESSAGE) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\n// color is value2 (velocity)\nfunction SetLED(messageType, note, color, state) {\n    for (i = 0; i < numTracks; i++) {\n        if (Track.IsArmed(i)) {\n\n            MIDI.SendMIDI(0x90, 0x8, ROW_2_BUTTONS[i], 0x3C, OFF);\n        }\n    }\n}\n\n// a function that handles the Device button LED and state\nfunction HandleDeviceButton() {\n    ClearRow2LEDs();\n    BUTTON_STATE++;\n\n    if (BUTTON_STATE == 2) {\n        BUTTON_STATE = 0;\n    }\n\n    // if the DEVICE_BUTTON is pressed and the button state doesn\'t equal 0, set the LED to yellow\n    if (BUTTON_STATE != 0) {\n        MIDI.SendMIDI(0x90, 0x8, DEVICE_BUTTON, 0x3F, 0xF);\n    } else {\n        MIDI.SendMIDI(0x80, 0x8, DEVICE_BUTTON, 0x3C, 0xF);\n    }\n}\n\n// a function that determines which row of knobs a knob is from and assigns an index value of 0, 1, or 2\nfunction GetKnobRow(knob) {\n    if (knob >= ROW_1_KNOBS[0] && knob <= ROW_1_KNOBS[7]) {\n        return 0;\n    } else if (knob >= ROW_2_KNOBS[0] && knob <= ROW_2_KNOBS[7]) {\n        return 1;\n    } else if (knob >= ROW_3_KNOBS[0] && knob <= ROW_3_KNOBS[7]) {\n        return 2;\n    }\n}\n\n// a function that gets the button row using the button value\nfunction GetButtonRow(button) {\n    if (button >= ROW_1_BUTTONS[0] && button <= ROW_1_BUTTONS[7]) {\n        return 1;\n    } else if (button >= ROW_2_BUTTONS[0] && button <= ROW_2_BUTTONS[7]) {\n        return 2;\n    }\n}\n\n// a function that gets the knob index using the knob value and the appropriate knob array\nfunction GetKnobIndex(value1) {\n    // determine the row of the knob\n    row = GetKnobRow(value1);\n    // based on the row, determine the index of the knob in ROW_1_KNOBS or ROW_2_KNOBS using indexof\n    if (row == 1) {\n        return ROW_1_KNOBS.indexOf(value1);\n    } else if (row == 2) {\n        return ROW_2_KNOBS.indexOf(value1);\n    }\n}\n\nfunction HandleSendSelect(value1, value2) {\n    if (value1 == SEND_SELECT_BUTTON_UP && value2 == ON) {\n        number_of_sends = Track.NumSendTracks(0);\n\n        if (PAGE < number_of_sends / 2) {\n            PAGE++;\n        }\n    }\n    if (value1 == SEND_SELECT_BUTTON_DOWN && value2 == ON) {\n        number_of_sends = Track.NumSendTracks(0);\n\n        if (PAGE > 1) {\n            PAGE--;\n\n            // set the LED\n            //ModeButtonsLEDs(BUTTON_STATE, flag);\n        }\n    }\n\n}\n\n// a function that handles the selected track state and LEDs\nfunction HandleTrackSelect(value1) {\n\n    // fill the track variable by determining the index of the ROW_1_BUTTONS array\n    track = ROW_1_BUTTONS.indexOf(value1);\n\n    // turn off all the ROW_1_BUTTONS\n    for (i = 0; i < 8; i++) {\n        MIDI.SendMIDI(0x80, 0x8, ROW_1_BUTTONS[i], 0x3C, OFF);\n    }\n\n    // turn on the selected ROW_1_BUTTON\n    MIDI.SendMIDI(0x90, 0x8, ROW_1_BUTTONS[track], 0x3F, 0x3E);\n    Track.Select(track + SELECT_OFFSET);\n}\n\n// a function that updates the bottom row of LEDs based on the selected side button (which changes the BOTTOM_BUTTON_STATE)\nfunction UpdateBottomButtonState(value1, value2) {\n    // Mute == 0, Solo == 1, Arm == 2\n    if (value1 == MUTE_BUTTON && value2 == ON) {\n        BOTTOM_BUTTON_STATE = 0;\n        MIDI.SendMIDI(0x90, 0x8, MUTE_BUTTON, 0x3F, 0x3E);\n        MIDI.SendMIDI(0x80, 0x8, SOLO_BUTTON, 0x3F, 0x3E);\n        MIDI.SendMIDI(0x80, 0x8, REC_ARM_BUTTON, 0x3F, 0x3E);\n    }\n    if (value1 == SOLO_BUTTON && value2 == ON) {\n        BOTTOM_BUTTON_STATE = 1;\n        MIDI.SendMIDI(0x90, 0x8, SOLO_BUTTON, 0x3F, 0x3E);\n        MIDI.SendMIDI(0x80, 0x8, REC_ARM_BUTTON, 0x3F, 0x3E);\n        MIDI.SendMIDI(0x80, 0x8, MUTE_BUTTON, 0x3F, 0x3E);\n    }\n    if (value1 == REC_ARM_BUTTON && value2 == ON) {\n        BOTTOM_BUTTON_STATE = 2;\n        MIDI.SendMIDI(0x90, 0x8, REC_ARM_BUTTON, 0x3F, 0x3E);\n        MIDI.SendMIDI(0x80, 0x8, MUTE_BUTTON, 0x3F, 0x3E);\n        MIDI.SendMIDI(0x80, 0x8, SOLO_BUTTON, 0x3F, 0x3E);\n    }\n    ClearRow2LEDs();\n    UpdateBottomButtonLEDs();\n}\n\n// a function that is called to update the LEDs of the bottom row of buttons\nfunction UpdateBottomButtonLEDs() {\n\n    for (i = 0; i < 8; i++) {\n        track = SELECT_OFFSET + i;\n        if (BOTTOM_BUTTON_STATE == 0) {\n            if (Track.IsMuted(track)) {\n                MIDI.SendMIDI(0x90, 0x8, ROW_2_BUTTONS[i], 0x3E, 0x0C);\n            } else {\n                MIDI.SendMIDI(0x80, 0x8, ROW_2_BUTTONS[i], 0x3E, 0x0C);\n            }\n        }\n\n        if (BOTTOM_BUTTON_STATE == 1) {\n            if (Track.IsSoloed(track)) {\n                MIDI.SendMIDI(0x90, 0x8, ROW_2_BUTTONS[i], 0x3C, 0x3F);\n            } else {\n                MIDI.SendMIDI(0x80, 0x8, ROW_2_BUTTONS[i], 0x3C, 0x3F);\n            }\n        }\n\n        if (BOTTOM_BUTTON_STATE == 2) {\n            if (Track.IsArmed(track)) {\n                MIDI.SendMIDI(0x90, 0x8, ROW_2_BUTTONS[i], 0x0F, 0xF);\n            } else {\n                MIDI.SendMIDI(0x80, 0x8, ROW_2_BUTTONS[i], 0x0F, 0xF);\n            }\n        }\n\n\n    }\n}\n// a function that sets all of the LEDs on the bottom row of buttons to off\nfunction ClearRow2LEDs() {\n    for (i = 0; i < 8; i++) {\n        MIDI.SendMIDI(0x80, 0x8, ROW_2_BUTTONS[i], 0x3C, OFF);\n    }\n\n}\n\n// A function that updates the state of an LED based on the value of the button, the value of the LED, the color and the flag. If the flag is 0, then the LED is turned off. If the flag is 1, then the LED is turned on.\nfunction UpdateLED(value1, value2, color, flag) {\n\n    if (flag == 0) {\n        MIDI.SendMIDI(0x80, 0x8, value1, color, OFF);\n    } else if (flag == 1) {\n        MIDI.SendMIDI(0x90, 0x8, value1, color, 0x3E);\n    }\n}\n\n\n/// a function called HandleMuteButton that handles the mute button\nfunction HandleMuteButton(value1, value2) {\n    selected_track = GetSelectedTrack();\n    index = ROW_2_BUTTONS.indexOf(value1);\n    track = selected_track + index;\n\n    // if the mute button is pressed\n    if (value1 >= ROW_2_BUTTONS[0] && value1 <= ROW_2_BUTTONS[7] && value2 == ON) {\n\n        // if the track is muted\n        if (Track.IsMuted(track)) {\n            // unmute the track\n            Track.Mute(track, false);\n            MIDI.SendMIDI(0x80, 0x8, ROW_2_BUTTONS[index], 0x3E, 0x0C);\n            // if the track is not muted\n        } else {\n            // mute the track\n            Track.Mute(track, true);\n            MIDI.SendMIDI(0x90, 0x8, ROW_2_BUTTONS[index], 0x3E, 0x0C);\n            // turn on the LED\n        }\n    }\n}\n\n/// a function that handles the solo button\nfunction HandleSoloButton(value1, value2) {\n    selected_track = GetSelectedTrack();\n    index = ROW_2_BUTTONS.indexOf(value1);\n    track = selected_track + index;\n\n    // if the solo button is pressed\n    if (value1 >= ROW_2_BUTTONS[0] && value1 <= ROW_2_BUTTONS[7] && value2 == ON) {\n\n        // if the track is soloed\n        if (Track.IsSoloed(track)) {\n            // unsolo the track\n            Track.Solo(track, false);\n            MIDI.SendMIDI(0x80, 0x8, ROW_2_BUTTONS[index], 0x3C, 0x3F);\n            // if the track is not soloed\n        } else {\n            // solo the track\n            Track.Solo(track, true);\n            MIDI.SendMIDI(0x90, 0x8, ROW_2_BUTTONS[index], 0x3C, 0x3F);\n            // turn on the LED\n        }\n    }\n}\n\n// a function called HandleRecArmButton that handles the rec arm button\nfunction HandleRecArmButton(value1, value2) {\n    ClearRow2LEDs();\n    selected_track = GetSelectedTrack();\n    index = ROW_2_BUTTONS.indexOf(value1);\n    track = selected_track + index;\n\n    // if the rec arm button is pressed\n    if (value1 >= ROW_2_BUTTONS[0] && value1 <= ROW_2_BUTTONS[7] && value2 == ON) {\n\n        // if the track is armed\n        if (Track.IsArmed(track)) {\n            // disarm the track\n            Track.Arm(track, false);\n            MIDI.SendMIDI(0x80, 0x8, ROW_2_BUTTONS[index], 0x0F, 0xF);\n            // if the track is not armed\n        } else {\n            // arm the track\n            Track.Arm(track, true);\n            MIDI.SendMIDI(0x90, 0x8, ROW_2_BUTTONS[index], 0x0F, 0xF);\n            // turn on the LED\n        }\n    }\n}\n\nfunction HandleTrackSelection(value1, value2, messageType) {\n    // depending on the value of BUTTON_STATE, the track selection will be handled differently - when 0, it will shift tracks by 1, when 1, it will shift tracks by 8.\n\n    if (BUTTON_STATE == 0) {\n        if (value2 == ON) {\n            if (value1 == TRACK_SELECT_BUTTON_LEFT) {\n                // if the track is not the first track, then select the previous track\n                if (SELECT_OFFSET > 0) {\n                    SELECT_OFFSET--;\n                    Globals.Log(SELECT_OFFSET + " farts");\n                }\n                else {\n                    SELECT_OFFSET = 0;\n                }\n            } else if (value1 == TRACK_SELECT_BUTTON_RIGHT) {\n                // if the track is not the last track, then select the next track\n                if (SELECT_OFFSET != Track.NumTracks() - 1) {\n                    SELECT_OFFSET++;\n                    Globals.Log(SELECT_OFFSET + " smiles");\n                }\n            }\n        }\n    }\n    if (BUTTON_STATE == 1) {\n        if (value2 == ON) {\n            if (value1 == TRACK_SELECT_BUTTON_LEFT) {\n                if (SELECT_OFFSET > 8) {\n                    SELECT_OFFSET -= 8;\n                }\n                else {\n                    SELECT_OFFSET = 0;\n                }\n            } else if (value1 == TRACK_SELECT_BUTTON_RIGHT) {\n                if (SELECT_OFFSET < Track.NumTracks() - 8) {\n                    SELECT_OFFSET += 8;\n                }\n                else {\n                    SELECT_OFFSET = Track.NumTracks() - 8;\n                }\n            }\n        }\n    }\n    Track.Select(SELECT_OFFSET);\n}\n\n')))}u.isMDXComponent=!0}}]);